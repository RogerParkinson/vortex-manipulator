/*
 * Gallery.cpp
 *
 *  Created on: 4/06/2013
 *      Author: roger
 */

#include "Gallery.h"

static uint16_t myicon[] PROGMEM = {
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x5acb,0x9492,0xffdf,0xffdf,0xffdf,0xffdf,0x8c51,0x630c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x8c51,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xf79e,0x8c51,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xffdf,0xffdf,0xffdf,0xf79e,0xc618,0xeec2,0xffdf,0xffdf,0xef5d,0xec02,0xef5d,0xffdf,0xffdf,0xffdf,0xffdf,0x8410,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0xffdf,0xffdf,0xffdf,0xffdf,0xeec2,0xeec2,0xeec2,0xf79e,0xffdf,0xec02,0xec02,0xec02,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0xf79e,0xffdf,0xffdf,0xffdf,0xffdf,0xeec2,0xeec2,0xeec2,0xef5d,0xf79e,0xec02,0xec02,0xec02,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xb596,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0x9492,0xeec2,0xffdf,0xffdf,0xd69a,0xec02,0xe71c,0xffdf,0xef5d,0x109d,0x109d,0xc618,0xffdf,0xffdf,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0xf79e,0xffdf,0xb596,0x1746,0x4f42,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0x109d,0x109d,0x109d,0x109d,0xffdf,0xffdf,0xffdf,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0xffdf,0xffdf,0x1746,0x1746,0x1746,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xf79e,0x109d,0x109d,0xe71c,0xffdf,0xffdf,0xef5d,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0xf79e,0xffdf,0xffdf,0x1746,0x4f42,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xff9e,0xffdf,0xffdf,0xff9e,0xff9e,0xff9e,0xfedb,0xffdf,0xf79e,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0xbdd7,0xffdf,0xffdf,0xf79e,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xff9e,0xff9e,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xf79e,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0xce59,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xff9e,0xff9e,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xf79e,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x39c7,0x528a,0x528a,0xffdf,0xffdf,0xffdf,0xffdf,0xff9e,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xef5d,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xffdf,0xff9e,0xff9e,0xffdf,0xe882,0xe882,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0x738e,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xffdf,0xffdf,0xe882,0xe882,0xe882,0xe882,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xdedb,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xef5d,0xffdf,0xffdf,0xe882,0xe882,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xf79e,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xb596,0xffdf,0xf79e,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xdedb,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xe71c,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xdedb,0x528a,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7bcf,0xffdf,0xffdf,0xffdf,0x9492,0x6b4d,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0};

Gallery::Gallery() :
		App() {
	logger = loggerFactory.getLogger("Gallery");
}
void Gallery::init() {
	m_icon = new Icon(28, myicon);
}
void Gallery::setup() {
	Graphics.setRotation((uint8_t)0);
	Graphics.fillScreen((uint16_t)WHITE);
	if (m_root) {
		m_root.close();
	}
	m_root = SD.open(PSTR("/"));
	if (!m_root) {
		logger->error("failed to open root");
		return;
	}
	m_root.rewindDirectory();
	char *n = findNextFile();
	if (n != NULL) {
		imgDraw(n,0,0);
	}
}

boolean Gallery::touch(TS_Point p) {
	if (p.x > 270) {
		return true;
	}
	char *n = findNextFile();
	if (n != NULL) {
		imgDraw(n,0,0);
		return true;
	}
	return false;
}

char *Gallery::findNextFile() {
	while (true) {
		File entry = m_root.openNextFile();
		if (!entry) {
			// no more files
			logger->info("no more files");
			break;
		}
		if (entry.isDirectory()) {
			entry.close();
			continue;
		}
		char *pch = NULL;
		pch = strstr (entry.name(),".BMP");
		if (pch == NULL) {
			pch = strstr (entry.name(),".TFT");
		}
		if (pch != NULL) {
			logger->debug("%s selected",entry.name());
			strcpy(m_lastName,entry.name());
			entry.close();
			return &m_lastName[0];
		}
		entry.close();
	}
	logger->info("failed to find a file");
	return NULL;
}

void Gallery::display() {
}

void Gallery::imgDraw(char *filename, int x, int y) {

	  File     bmpFile;
	  int      bmpWidth, bmpHeight;   // W+H in pixels
	  uint8_t  bmpDepth;              // Bit depth (currently must be 24)
	  uint32_t bmpImageoffset;        // Start of image data in file
	  uint32_t rowSize;               // Not always = bmpWidth; may have padding
	  uint8_t  sdbuffer[3*BUFFPIXEL]; // pixel buffer (R+G+B per pixel)
	  uint16_t buffidx = sizeof(sdbuffer); // Current position in sdbuffer
	  boolean  goodBmp = false;       // Set to true on valid header parse
	  boolean  flip    = true;        // BMP is stored bottom-to-top
	  int      w, h, row, col;
	  uint8_t  r, g, b;
	  uint32_t pos = 0, startTime = millis();

	  uint16_t awColors[320];  // hold colors for one row at a time...

	  if((x >= Graphics.width()) || (y >= Graphics.height())) return;

	  logger->debug("loading image [%s]",filename);

	  // Open requested file on SD card
	  if (!(bmpFile = SD.open(filename))) {
		  logger->error("File not found [%s]",filename);
	    return;
	  }

	  // Parse BMP header
	  if(Hardware.read16(bmpFile) == 0x4D42) { // BMP signature
		logger->debug("File size: %d",Hardware.read32(bmpFile));
	    (void)Hardware.read32(bmpFile); // Read & ignore creator bytes
	    bmpImageoffset = Hardware.read32(bmpFile); // Start of image data
	    logger->debug("Image Offset: %d",bmpImageoffset);
	    // Read DIB header
	    logger->debug("Header size: %d",Hardware.read32(bmpFile));
	    bmpWidth  = Hardware.read32(bmpFile);
	    bmpHeight = Hardware.read32(bmpFile);
	    if(Hardware.read16(bmpFile) == 1) { // # planes -- must be '1'
	      bmpDepth = Hardware.read16(bmpFile); // bits per pixel
	      logger->debug("Bit Depth: %d",bmpDepth);

	      if((bmpDepth == 24) && (Hardware.read32(bmpFile) == 0)) { // 0 = uncompressed

	        goodBmp = true; // Supported BMP format -- proceed!
	        logger->debug("Image size %d %d",bmpWidth,bmpHeight);

	        // BMP rows are padded (if needed) to 4-byte boundary
	        rowSize = (bmpWidth * 3 + 3) & ~3;

	        // If bmpHeight is negative, image is in top-down order.
	        // This is not canon but has been observed in the wild.
	        if(bmpHeight < 0) {
	          bmpHeight = -bmpHeight;
	          flip      = false;
	        }

	        // Crop area to be loaded
	        w = bmpWidth;
	        h = bmpHeight;
	        if((x+w-1) >= Graphics.width())  w = Graphics.width()  - x;
	        if((y+h-1) >= Graphics.height()) h = Graphics.height() - y;

	        for (row=0; row<h; row++) { // For each scanline...

	          // Seek to start of scan line.  It might seem labor-
	          // intensive to be doing this on every line, but this
	          // method covers a lot of gritty details like cropping
	          // and scanline padding.  Also, the seek only takes
	          // place if the file position actually needs to change
	          // (avoids a lot of cluster math in SD library).
	          if(flip) // Bitmap is stored bottom-to-top order (normal BMP)
	            pos = bmpImageoffset + (bmpHeight - 1 - row) * rowSize;
	          else     // Bitmap is stored top-to-bottom
	            pos = bmpImageoffset + row * rowSize;
	          if(bmpFile.position() != pos) { // Need seek?
	            bmpFile.seek(pos);
	            buffidx = sizeof(sdbuffer); // Force buffer reload
	          }

	          for (col=0; col<w; col++) { // For each pixel...
	            // Time to read more pixel data?
	            if (buffidx >= sizeof(sdbuffer)) { // Indeed
	              bmpFile.read(sdbuffer, sizeof(sdbuffer));
	              buffidx = 0; // Set index to beginning
	            }

	            // Convert pixel from BMP to TFT format, push to display
	            b = sdbuffer[buffidx++];
	            g = sdbuffer[buffidx++];
	            r = sdbuffer[buffidx++];
	            awColors[col] = Graphics.color565(r,g,b);
	          } // end pixel
	          Graphics.writeRect(0, row, w, 1, awColors);
	        } // end scanline
	        logger->debug("Loaded in %d ms",millis() - startTime);
	      } // end goodBmp
	    }
	  }

	  bmpFile.close();
	  if(!goodBmp) {
		  logger->error("BMP format not recognized.");
	  }
}

Gallery::~Gallery() {
}

App *gallery = new Gallery();




